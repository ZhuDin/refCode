第4章 认识所有权

    所有权是Rust中独特的一个功能，保证其在没有垃圾回收机制的前提下保障内存安全。

·栈和堆

    栈和堆都是代码在运行时可以使用的内存空间，它们通常以不同的结构组织而成。
    
    栈会以人们放入值的顺序来存在它们，并以相反的顺序将值取出。即“后进先出”
策略。所有存储在栈中的数据都必须拥有一个已知且固定的大小。

    对于那些在编译期间无法确定大小的数据，只能将它们存储在堆中。堆空间的管理是
较为松散的：当希望将数据放入堆中时，就可以请求特定大小的空间。操作系统会根据请
求在堆中找到一块足够大的可用空间，将它标记为已使用，并把指向这片空间的地址的指
针返回。这一过程就是堆分配。而由于指针的大小是固定的且可以在编译期确定，所以可
以将指针存储在栈中。当要访问指针所指向的具体数据时，可以通过指针指向的地址来访
问。

·所有权规则

    Rust中的每一个值都有一个对应的变量作为它的所有者

    在同一时间内，值有且仅有一个所有者

    当所有者离开自己的作用域时，它持有的值就会被释放掉

·变量作用域

·String类型

    可以调用from函数根据字符串字面量来创建一个String实例。
如：let s = String::from("hello");

·内存与分配

    对于String类型而言，为了支持一个可变的、可增长的文本类型，需要在堆上分配一
块在编译时未知大小的内存来存放数据。这同时也意味着：
    
    - 使用的内存是由操作系统在运行时动态分配出来的

    - 当使用完String时，需要通过某种方式来将这些内存归还给操作系统

    Rust内存会自动地在拥有它的变量离开作用或后进行释放。变量离开作用域时，会调
用一个叫作drop的特殊函数。String类型的作者可能在这个函数中编写释放内存的代码。

    Rust会在作用域结束的地方（即}处）自动调用drop函数。

    存储在堆上的变量执行赋值操作时，其值会移动给另一个变量。原来的变量会被废弃。
如：let s1 = String::from("hello");   let s2 = s1;
以上代码执行赋值后，变量s1会被废弃，不再被视为一个有效的变量。因此Rust不需要在
离开s1的作用域后清理任何东西以将内存归还给操作系统。而s2会成为唯一的指向堆数据
"hello"的变量。由于以上代码中Rust在给堆数据赋值时使第一个变量无效了，故使用新的
术语移动(move)来描述这一行为。

    Rust永远不会自动地创建数据的深度拷贝。当需要去深度拷贝堆上的数据时，可以使
用一个名为clone的方法。

    Rust提供了一个名为Copy的特性，可以用于存储在栈上的数据类型。一旦变量拥有了
Copy特性，就可以在赋值后仍保持可用性。如果一个类型本身或这种类型的任意成员实现
了Drop这种特性，那么Rust就不允许其实现Copy特性。

    下面是一些拥有Copy特性的类型：

    - 所有的整数类型

    - 仅拥有两种值(true和false)的布尔类型

    - 字符类型：char

    - 所有浮点类型

    - 如果元组包含的所有字段类型都Copy的，那么这个元组也是拥有Copy特性的类型

-------------------------------------------------------------------------------