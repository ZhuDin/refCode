第4章 认识所有权

    所有权是Rust中独特的一个功能，保证其在没有垃圾回收机制的前提下保障内存安全。

·栈和堆

    栈和堆都是代码在运行时可以使用的内存空间，它们通常以不同的结构组织而成。
    
    栈会以人们放入值的顺序来存在它们，并以相反的顺序将值取出。即“后进先出”
策略。所有存储在栈中的数据都必须拥有一个已知且固定的大小。

    对于那些在编译期间无法确定大小的数据，只能将它们存储在堆中。堆空间的管理是
较为松散的：当希望将数据放入堆中时，就可以请求特定大小的空间。操作系统会根据请
求在堆中找到一块足够大的可用空间，将它标记为已使用，并把指向这片空间的地址的指
针返回。这一过程就是堆分配。而由于指针的大小是固定的且可以在编译期确定，所以可
以将指针存储在栈中。当要访问指针所指向的具体数据时，可以通过指针指向的地址来访
问。

·所有权规则

    - Rust中的每一个值都有一个对应的变量作为它的所有者

    - 在同一时间内，值有且仅有一个所有者

    - 当所有者离开自己的作用域时，它持有的值就会被释放掉

·变量作用域

·String类型

    可以调用from函数根据字符串字面量来创建一个String实例。
如：let s = String::from("hello");

·内存与分配

    对于String类型而言，为了支持一个可变的、可增长的文本类型，需要在堆上分配一
块在编译时未知大小的内存来存放数据。这同时也意味着：
    
    - 使用的内存是由操作系统在运行时动态分配出来的

    - 当使用完String时，需要通过某种方式来将这些内存归还给操作系统

    Rust内存会自动地在拥有它的变量离开作用或后进行释放。变量离开作用域时，会调
用一个叫作drop的特殊函数。String类型的作者可能在这个函数中编写释放内存的代码。

    Rust会在作用域结束的地方（即}处）自动调用drop函数。

    存储在堆上的变量执行赋值操作时，其值会移动给另一个变量。原来的变量会被废弃。
如：let s1 = String::from("hello");   let s2 = s1;
以上代码执行赋值后，变量s1会被废弃，不再被视为一个有效的变量。因此Rust不需要在
离开s1的作用域后清理任何东西以将内存归还给操作系统。而s2会成为唯一的指向堆数据
"hello"的变量。由于以上代码中Rust在给堆数据赋值时使第一个变量无效了，故使用新的
术语移动(move)来描述这一行为。

    Rust永远不会自动地创建数据的深度拷贝。当需要去深度拷贝堆上的数据时，可以使
用一个名为clone的方法。

    Rust提供了一个名为Copy的特性，可以用于存储在栈上的数据类型。一旦变量拥有了
Copy特性，就可以在赋值后仍保持可用性。如果一个类型本身或这种类型的任意成员实现
了Drop这种特性，那么Rust就不允许其实现Copy特性。

    下面是一些拥有Copy特性的类型：

    - 所有的整数类型

    - 仅拥有两种值(true和false)的布尔类型

    - 字符类型：char

    - 所有浮点类型

    - 如果元组包含的所有字段类型都Copy的，那么这个元组也是拥有Copy特性的类型

-------------------------------------------------------------------------------
·所有权与函数

    将值传递给函数在语义上类似于对变量进行赋值。将变量传递给函数将会触发移动
或复制。

    示例：

    fn main() {
        let s = String::from("hello");  // 变量s进入作用域，'hello'存储在堆中

        tokes_ownership(s);             // s的值被传入函数，触发移动
        // s不再有效，堆中的对象的所有权被转移

        let x = 5;                      // 变量x进入作用域，5存储在栈中

        makes_copy(x);                  // x的值被传入函数，触发复制
        // 由于x的值是存储在栈中的i32类型且具有Copy特性，故传递赋值后仍可用
    } // x首先离开作用域，随后是s

·返回值和作用域

    函数在返回值的过程中也会发生所有权的转移。

    变量所有权的转移遵循相同的模式：将一个值赋值给另一个变量时就会转移所有权。
当一个持有堆数据的变量离开作用域时，它的数据就会被drop清理回收，除非这些数据的
所有权移动到了另一个变量上。

--------------------------------------------------------------------------------
·引用与借用

    &代表引用语义，它允许在不获取所有权的前提下使用值。如

    fn main() {
        let s1 = String::from("hello");

        let len = calculate_length(&s1);    // s1变量的所有权不转移
    }
    
    fn calculate_length(s: &String) -> usize { // s是一个指向String的引用
        s.len()
    }   // s离开作用域，它不持有自己所指向值的所有权
    
    当一个函数使用引用而不是值本身作为参数时，我们便不需要为了归还所有权而特意
去返回值。

    这种通过引用传递参数给函数的方法也被称为借用(borrowing)。与变量类似，引用是
默认不可变的，Rust不允许修改引用指向的值。

·可变引用

    如果将变量声明为mut，即可变的，再使用&mut来给函数传入一个可变引用，并将函数
签名修改为some_string: &mut String可以使其接收一个可变引用作为参数。如

    fn main() {
        let mut s = String::from("hello");  // 变量声明为mut

        change(&mut s);  // 传入可变引用
    }

    fn change(some_string: &mut String) {   // 修改函数签名为可变类型
        some_string.push_str(", world");
    }

    但可引用在使用上有一个很大的限制：对于特定作用域中的特定数据来说，一次只能
声明一个可变引用。

    与大部分语言类似，可以通过花括号来创建一个新的作用域范围。这就可以创建多个
可变引用，只是这些可变引用不会同时存在。如：

    let mut s = String::from("hello");

    {
        let r1 = &mut s;    // 创建可变引用
    }   // 由于r1在这里离开了作用域，故可以再创建一个可变引用

    let r2 = &mut s;    // 创建可变引用

    不能在拥有不可变引用 的同时创建可变引用。不过，同时存在多个不可变引用是合
理的，对数据的只读操作不会影响到其他读取数据的用户。如：

    let mut s = String::from("hello");

    let s1 = &s;    // 创建不可变引用

    let s2 = &s;    // 创建另一个不可变引用

    let r3 = &mut s;    // 报错！不允许同时存在可变与不可变引用

·悬垂引用

·引用的无则

    - 在任何一段给定的时间里，要么只能拥有一个可变引用，要么只能拥有任意数量的
      不可变引用

    - 引用总是有效的

--------------------------------------------------------------------------------
·切片

    除了引用，Rust还有另外一种不持有所有权的数据类型：切片(slice)。切片允许我们
引用集合中某一段连续的元素序列，而不是整个集合。

    我们可以在一对方括号中指定切片的范围区间[starting_index..ending_index]，其
中starting_index是切片起始位置的索引值，ending_index是切片终止位置的下一个索引
值。

    切片数据结构在内部存储了指向起始位置的引用和一个描述切片长度的字段。Rust范
围语法..有一个小的语法糖：当希望范围从第一个元素开始时，则可以活力两个点号之前
的值；同样地，如果切片想要包含最后一个字节，也可以省略双点号之后的值。